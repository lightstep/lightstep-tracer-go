package lightstep

import (
	"flag"
	"fmt"
	"os"
	"path"
	"reflect"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"golang.org/x/net/context"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"

	"github.com/golang/glog"
	google_protobuf "github.com/golang/protobuf/ptypes/timestamp"
	cpb "github.com/lightstep/lightstep-tracer-go/collectorpb"
	"github.com/lightstep/lightstep-tracer-go/thrift_rpc"
	"github.com/opentracing/basictracer-go"
	ot "github.com/opentracing/opentracing-go"
)

const (
	spansDropped  = "spans.dropped"
	collectorPath = "/_rpc/v1/reports/binary"

	defaultPlainPort  = 80
	defaultSecurePort = 443

	defaultCollectorHost = "collector.lightstep.com"
	defaultAPIHost       = "api.lightstep.com"

	// See the comment for shouldFlush() for more about these tuning
	// parameters.
	defaultMaxReportingPeriod = 2500 * time.Millisecond
	minReportingPeriod        = 500 * time.Millisecond

	// ParentSpanGUIDKey is the tag key used to record the relationship
	// between child and parent spans.
	ParentSpanGUIDKey = "parent_span_guid"

	TracerPlatformValue = "go"
	TracerVersionValue  = "0.9.1"

	TracerPlatformKey        = "lightstep.tracer_platform"
	TracerPlatformVersionKey = "lightstep.tracer_platform_version"
	TracerVersionKey         = "lightstep.tracer_version"
	ComponentNameKey         = "lightstep.component_name"
	GUIDKey                  = "lightstep.guid" // <- runtime guid, not span guid
	HostnameKey              = "lightstep.hostname"
	CommandLineKey           = "lightstep.command_line"

	ellipsis = "â€¦"
)

// TODO move these to Options
var (
	flagMaxLogMessageLen     = flag.Int("lightstep_max_log_message_len_bytes", 1024, "the maximum number of bytes used by a single log message")
	flagMaxPayloadFieldBytes = flag.Int("lightstep_max_log_payload_field_bytes", 1024, "the maximum number of bytes exported in a single payload field")
	flagMaxPayloadTotalBytes = flag.Int("lightstep_max_log_payload_max_total_bytes", 4096, "the maximum number of bytes exported in an entire payload")
)

// A set of counter values for a given time window
type counterSet struct {
	droppedSpans int64
}

// Endpoint describes a collection or web API host/port and whether or
// not to use plaintext communicatation.
type Endpoint struct {
	Host      string `yaml:"host" usage:"host on which the endpoint is running"`
	Port      int    `yaml:"port" usage:"port on which the endpoint is listening"`
	Plaintext bool   `yaml:"plaintext" usage:"whether or not to encrypt data send to the endpoint"`
}

// Options control how the LightStep Tracer behaves.
type Options struct {
	// AccessToken is the unique API key for your LightStep project.  It is
	// available on your account page at https://app.lightstep.com/account
	AccessToken string `yaml:"access_token" usage:"access token for reporting to LightStep"`

	// Collector is the host, port, and plaintext option to use
	// for the collector.
	Collector Endpoint `yaml:"collector"`

	// Tags are arbitrary key-value pairs that apply to all spans generated by
	// this Tracer.
	Tags ot.Tags

	// LightStep is the host, port, and plaintext option to use
	// for the LightStep web API.
	LightStepAPI Endpoint `yaml:"lightstep_api"`

	// MaxBufferedSpans is the maximum number of spans that will be buffered
	// before sending them to a collector.
	MaxBufferedSpans int `yaml:"max_buffered_spans"`

	// ReportingPeriod is the maximum duration of time between sending spans
	// to a collector.  If zero, the default will be used.
	ReportingPeriod time.Duration `yaml:"reporting_period"`

	ReportTimeout time.Duration `yaml:"report_timeout"`

	// DropSpanLogs turns log events on all Spans into no-ops.
	DropSpanLogs bool `yaml:"drop_span_logs"`

	// Set Verbose to true to enable more text logging.
	Verbose bool

	UseGRPC bool
}

// NewTracer returns a new Tracer that reports spans to a LightStep
// collector.
func NewTracer(opts Options) ot.Tracer {
	options := basictracer.DefaultOptions()
	options.ShouldSample = func(_ uint64) bool { return true }
	if opts.UseGRPC {
		options.Recorder = NewRecorder(opts)
	} else {
		// convert opts to thrift_rpc.Options
		thriftOpts := thrift_rpc.Options{
			AccessToken:      opts.AccessToken,
			Collector:        thrift_rpc.Endpoint{opts.Collector.Host, opts.Collector.Port, opts.Collector.Plaintext},
			Tags:             opts.Tags,
			LightStepAPI:     thrift_rpc.Endpoint{opts.LightStepAPI.Host, opts.LightStepAPI.Port, opts.LightStepAPI.Plaintext},
			MaxBufferedSpans: opts.MaxBufferedSpans,
			ReportingPeriod:  opts.ReportingPeriod,
			ReportTimeout:    opts.ReportTimeout,
			DropSpanLogs:     opts.DropSpanLogs,
			Verbose:          opts.Verbose,
			MaxLogMessageLen: int(*flagMaxLogMessageLen),
		}
		options.Recorder = thrift_rpc.NewRecorder(thriftOpts)
	}
	options.DropAllLogs = opts.DropSpanLogs
	return basictracer.NewWithOptions(options)
}

func FlushLightStepTracer(lsTracer ot.Tracer) error {
	basicTracer, ok := lsTracer.(basictracer.Tracer)
	if !ok {
		return fmt.Errorf("Not a LightStep Tracer type: %v", reflect.TypeOf(lsTracer))
	}

	basicRecorder := basicTracer.Options().Recorder
	lsRecorder, ok := basicRecorder.(*Recorder)
	if !ok {
		return fmt.Errorf("Not a LightStep Recorder type: %v", reflect.TypeOf(basicRecorder))
	}
	lsRecorder.Flush()
	return nil
}

// Recorder buffers spans and forwards them to a LightStep collector.
type Recorder struct {
	lock sync.Mutex

	// auth and runtime information
	attributes map[string]string
	startTime  time.Time

	// Time window of the data to be included in the next report.
	reportOldest   time.Time
	reportYoungest time.Time

	// buffered data
	buffer   spansBuffer
	counters counterSet // The unreported count

	lastReportAttempt  time.Time
	maxReportingPeriod time.Duration
	reportInFlight     bool

	// Remote service that will receive reports
	backend cpb.CollectorServiceClient

	// apiURL is the base URL of the LightStep web API, used for
	// explicit trace collection requests.
	apiURL string

	// accessToken is the access token used for explicit trace
	// collection requests.
	accessToken string

	tracerID uint64

	verbose bool

	// We allow our remote peer to disable this instrumentation at any
	// time, turning all potentially costly runtime operations into
	// no-ops.
	disabled bool
}

func NewRecorder(opts Options) basictracer.SpanRecorder {
	if len(opts.AccessToken) == 0 {
		// TODO maybe return a no-op recorder instead?
		panic("LightStep Recorder options.AccessToken must not be empty")
	}
	if opts.Tags == nil {
		opts.Tags = make(map[string]interface{})
	}
	// Set some default attributes if not found in options
	if _, found := opts.Tags[ComponentNameKey]; !found {
		opts.Tags[ComponentNameKey] = path.Base(os.Args[0])
	}
	if _, found := opts.Tags[GUIDKey]; found {
		panic(fmt.Sprintf("Passing in your own %v is no longer supported", GUIDKey))
	}
	if _, found := opts.Tags[HostnameKey]; !found {
		hostname, _ := os.Hostname()
		opts.Tags[HostnameKey] = hostname
	}
	if _, found := opts.Tags[CommandLineKey]; !found {
		opts.Tags[CommandLineKey] = strings.Join(os.Args, " ")
	}

	attributes := make(map[string]string)
	for k, v := range opts.Tags {
		attributes[k] = fmt.Sprint(v)
	}
	// Don't let the Options override these values. That would be confusing.
	attributes[TracerPlatformKey] = TracerPlatformValue
	attributes[TracerPlatformVersionKey] = runtime.Version()
	attributes[TracerVersionKey] = TracerVersionValue

	now := time.Now()
	rec := &Recorder{
		accessToken:        opts.AccessToken,
		attributes:         attributes,
		startTime:          now,
		reportOldest:       now,
		reportYoungest:     now,
		maxReportingPeriod: defaultMaxReportingPeriod,
		verbose:            opts.Verbose,
		apiURL:             getAPIURL(opts),
		tracerID:           genSeededGUID(),
	}
	rec.buffer.setDefaults()

	if opts.MaxBufferedSpans > 0 {
		rec.buffer.setMaxBufferSize(opts.MaxBufferedSpans)
	}

	// TODO: not using opts.ReportTimeout, use please
	//if opts.ReportTimeout > 0 {
	//	timeout = opts.ReportTimeout
	//}

	conn, err := grpc.Dial(getCollectorHostPort(opts), grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(nil, "")))
	if err != nil {
		rec.maybeLogError(err)
		return nil
	}
	// TODO: There is currenlty no way to close this connection
	rec.backend = cpb.NewCollectorServiceClient(conn)

	go rec.reportLoop()

	return rec
}

func (r *Recorder) RecordSpan(raw basictracer.RawSpan) {
	r.lock.Lock()
	defer r.lock.Unlock()

	// Early-out for disabled runtimes.
	if r.disabled {
		return
	}

	atomic.AddInt64(&r.counters.droppedSpans, int64(r.buffer.addSpans([]basictracer.RawSpan{raw})))
}

func translateSpanContext(sc basictracer.SpanContext) *cpb.SpanContext {
	return &cpb.SpanContext{
		TraceId: sc.TraceID,
		SpanId:  sc.SpanID,
		Baggage: sc.Baggage,
	}
}

func translateParentSpanID(pid uint64) []*cpb.Reference {
	return []*cpb.Reference{
		&cpb.Reference{
			Relationship: cpb.Reference_CHILD_OF,
			SpanContext:  &cpb.SpanContext{SpanId: pid},
		},
	}
}

func translateTime(t time.Time) *google_protobuf.Timestamp {
	return &google_protobuf.Timestamp{
		Seconds: t.Unix(),
		Nanos:   int32(t.Nanosecond()),
	}
}

func translateDuration(d time.Duration) uint64 {
	return uint64(d) / 1000
}

func translateDurationFromOldesYoungest(ot time.Time, yt time.Time) uint64 {
	return translateDuration(yt.Sub(ot))
}

func translateTags(tags ot.Tags) []*cpb.KeyValue {
	kvs := make([]*cpb.KeyValue, 0, len(tags))
	for key, tag := range tags {
		kv := cpb.KeyValue{Key: key}
		switch v := tag.(type) {
		case string:
			kv.Value = &cpb.KeyValue_StringValue{v}
		case int:
			kv.Value = &cpb.KeyValue_IntValue{int64(v)}
		case float64:
			kv.Value = &cpb.KeyValue_DoubleValue{v}
		case bool:
			kv.Value = &cpb.KeyValue_BoolValue{v}
		default:
			glog.Infof("value: %v, %T, is an unsupported type, and has been converted to string", v, v)
			// TODO: use reflection so that not all custom types have to be converted to string
			kv.Value = &cpb.KeyValue_StringValue{fmt.Sprint(v)}
		}
		kvs = append(kvs, &kv)
	}
	return kvs
}

// TODO: Implement once OT logs have been updated
func translateLogs(log []ot.LogData) []*cpb.Log {
	return nil
}

func translateRawSpan(rs basictracer.RawSpan) *cpb.Span {
	return &cpb.Span{
		SpanContext:    translateSpanContext(rs.Context),
		OperationName:  rs.Operation,
		References:     translateParentSpanID(rs.ParentSpanID),
		StartTimestamp: translateTime(rs.Start),
		DurationMicros: translateDuration(rs.Duration),
		Tags:           translateTags(rs.Tags),
		Logs:           translateLogs(rs.Logs),
	}
}

func convertRawSpans(rawSpans []basictracer.RawSpan) []*cpb.Span {
	spans := make([]*cpb.Span, len(rawSpans))
	for i, rs := range rawSpans {
		spans[i] = translateRawSpan(rs)
	}
	return spans
}

func translateAttributes(atts map[string]string) []*cpb.KeyValue {
	tags := make([]*cpb.KeyValue, 0, len(atts))
	for k, v := range atts {
		tags = append(tags, &cpb.KeyValue{Key: k, Value: &cpb.KeyValue_StringValue{v}})
	}
	return tags
}

func convertToTracer(atts map[string]string, id uint64) *cpb.Tracer {
	return &cpb.Tracer{
		TracerId: id,
		Tags:     translateAttributes(atts),
	}
}

func convertDroppedPendingToCounts(dp int64) []*cpb.MetricsSample {
	return []*cpb.MetricsSample{
		&cpb.MetricsSample{
			Name:  spansDropped,
			Value: &cpb.MetricsSample_IntValue{dp},
		},
	}
}

func convertToInternalMetrics(ot time.Time, yt time.Time, dp int64) *cpb.InternalMetrics {
	return &cpb.InternalMetrics{
		StartTimestamp: translateTime(ot),
		DurationMicros: translateDurationFromOldesYoungest(ot, yt),
		Counts:         convertDroppedPendingToCounts(dp),
	}
}

func (r *Recorder) makeReportRequest(rawSpans []basictracer.RawSpan, droppedPending int64) *cpb.ReportRequest {

	spans := convertRawSpans(rawSpans)
	tracer := convertToTracer(r.attributes, r.tracerID)
	internalMetrics := convertToInternalMetrics(r.reportOldest, r.reportYoungest, droppedPending)

	req := cpb.ReportRequest{
		Tracer:          tracer,
		Auth:            &cpb.Auth{r.accessToken},
		Spans:           spans,
		InternalMetrics: internalMetrics,
	}
	return &req

}

func (r *Recorder) Flush() {
	r.lock.Lock()

	if r.disabled {
		r.lock.Unlock()
		return
	}

	if r.reportInFlight == true {
		r.maybeLogError(fmt.Errorf("A previous Report is still in flight; aborting Flush()."))
		r.lock.Unlock()
		return
	}

	now := time.Now()
	r.lastReportAttempt = now
	r.reportYoungest = now

	rawSpans := r.buffer.current()
	// TODO the handling of droppedPending / droppedSpans is very
	// manual. Add abstraction for the second client-side count to
	// avoid duplicating all the atomic ops.
	droppedPending := atomic.SwapInt64(&r.counters.droppedSpans, 0)
	req := r.makeReportRequest(rawSpans, droppedPending)

	// Do *not* wait until the report RPC finishes to clear the buffer.
	// Consider the case of a new span coming in during the RPC: it'll be
	// discarded along with the data that was just sent if the buffers are
	// cleared later.
	r.buffer.reset()

	r.reportInFlight = true
	r.lock.Unlock() // unlock before making the RPC itself

	// Question: Where does context come in?
	resp, err := r.backend.Report(context.Background(), req)
	if err != nil {
		r.maybeLogError(err)
	} else if len(resp.Errors) > 0 {
		// These should never occur, since this library should understand what
		// makes for valid logs and spans, but just in case, log it anyway.
		for _, err := range resp.Errors {
			r.maybeLogError(fmt.Errorf("Remote report returned error: %s", err))
		}
	} else {
		r.maybeLogInfof("Report: resp=%v, err=%v", resp, err)
	}

	r.lock.Lock()
	r.reportInFlight = false
	if err != nil {
		// Restore the records that did not get sent correctly
		atomic.AddInt64(&r.counters.droppedSpans, int64(r.buffer.addSpans(rawSpans))+droppedPending)
		r.lock.Unlock()
		return
	}

	// Reset the buffers
	r.reportOldest = now
	r.reportYoungest = now

	// TODO something about timing
	r.lock.Unlock()

	if droppedPending != 0 {
		r.maybeLogInfof("client reported %d dropped spans", droppedPending)
	}

	for _, c := range resp.Commands {
		if c.Disable {
			r.Disable()
		}
	}
}

func (r *Recorder) Disable() {
	r.lock.Lock()
	defer r.lock.Unlock()

	if r.disabled {
		return
	}

	fmt.Printf("Disabling Runtime instance: %p", r)

	r.buffer.reset()
	r.disabled = true
}

// Every minReportingPeriod the reporting loop wakes up and checks to see if
// either (a) the Runtime's max reporting period is about to expire (see
// maxReportingPeriod()), (b) the number of buffered log records is
// approaching kMaxBufferedLogs, or if (c) the number of buffered span records
// is approaching kMaxBufferedSpans. If any of those conditions are true,
// pending data is flushed to the remote peer. If not, the reporting loop waits
// until the next cycle. See Runtime.maybeFlush() for details.
//
// This could alternatively be implemented using flush channels and so forth,
// but that would introduce opportunities for client code to block on the
// runtime library, and we want to avoid that at all costs (even dropping data,
// which can certainly happen with high data rates and/or unresponsive remote
// peers).
func (r *Recorder) shouldFlush() bool {
	r.lock.Lock()
	defer r.lock.Unlock()

	if time.Now().Add(minReportingPeriod).Sub(r.lastReportAttempt) > r.maxReportingPeriod {
		// Flush timeout.
		r.maybeLogInfof("--> timeout")
		return true
	} else if r.buffer.len() > r.buffer.cap()/2 {
		// Too many queued span records.
		r.maybeLogInfof("--> span queue")
		return true
	}
	return false
}

func (r *Recorder) reportLoop() {
	tickerChan := time.Tick(minReportingPeriod)
	for range tickerChan {
		r.maybeLogInfof("reporting alarm fired")

		// Kill the reportLoop() if we've been disabled.
		r.lock.Lock()
		if r.disabled {
			r.lock.Unlock()
			break
		}
		r.lock.Unlock()

		if r.shouldFlush() {
			r.Flush()
		}
	}
}

func getCollectorHostPort(opts Options) string {
	e := opts.Collector
	host := defaultCollectorHost
	if e.Host != "" {
		host = e.Host
	}
	port := defaultSecurePort
	if e.Plaintext {
		port = defaultPlainPort
	}
	if e.Port > 0 {
		port = e.Port
	}
	return fmt.Sprintf("%s:%d", host, port)
}

func getCollectorURL(opts Options) string {
	return getURL(opts.Collector,
		defaultCollectorHost,
		collectorPath)
}

func getAPIURL(opts Options) string {
	return getURL(opts.LightStepAPI, defaultAPIHost, "")
}

func getURL(e Endpoint, host, path string) string {
	if e.Host != "" {
		host = e.Host
	}
	httpProtocol := "https"
	port := defaultSecurePort
	if e.Plaintext {
		httpProtocol = "http"
		port = defaultPlainPort
	}
	if e.Port > 0 {
		port = e.Port
	}
	return fmt.Sprintf("%s://%s:%d%s", httpProtocol, host, port, path)
}
